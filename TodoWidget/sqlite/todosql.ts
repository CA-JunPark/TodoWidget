import * as SQLite from 'expo-sqlite';
import { ItemProps } from '../components/Item';
// TODO: use WidgetModule to update widget 
// import { NativeModules } from 'react-native';
// const { WidgetModule } = NativeModules;


// examples 
// // add
// const exampleItem = { id: 999, done: 0, title: 'Example Item', note: '', priority: '', notification: '', due: '2021-12-30', when_created: '', order_index: 0 };
// await todosql.addTodo(db, exampleItem);
// // get all
// const allItems = await todosql.getAllTodos(db);
// // console.log("All items:", allItems);
// // get one
// const item999 = await todosql.getTodoById(db, 999);
// console.log("Item 999:", item999);
// // update
// const updatedItem = { id: 999, done: 1, title: 'Updated Item', note: null, priority: null, notification: null, due: null, when_created: null, order_index: null };
// await todosql.updateTodo(db, updatedItem);
// const item9992 = await todosql.getTodoById(db, 999);
// console.log("Item 999:", item9992);
// // delete all
// await todosql.deleteAll(db);
// // Count all todos
// const count = await todosql.countAll(db);
// setResultCount(count);
// // Close database
// todosql.close(db);

export const createTableIfNotExists = async (db: SQLite.SQLiteDatabase | null) => {
    try {
        await db?.execAsync(`CREATE TABLE IF NOT EXISTS todo (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT DEFAULT NULL,
            due TEXT DEFAULT "",
            done INTEGER DEFAULT 0,
            priority TEXT DEFAULT "",
            note TEXT DEFAULT "",
            notification TEXT DEFAULT "",
            order_index INTEGER DEFAULT 0,
            when_created TEXT DEFAULT ""
        );`);
    } catch (error) {
        console.error("Error creating table:", error);
    }
};

const generateMaxId = async (db: SQLite.SQLiteDatabase | null)=> {
    // Get the maximum ID from the database.
    // If the database is empty, result will be null, and maxId will be set to 0.
    // If the database is not empty, result will have a maxId property with the maximum ID.
    // Add 1 to the maximum ID to get the ID for the new item.
    const result = await db?.getFirstAsync<{maxId: number}>('SELECT MAX(id) as maxId FROM todo');
    const maxId = result?.maxId ?? 0;
    return maxId + 1;
};

export const addTodo = async (db: SQLite.SQLiteDatabase | null, item: ItemProps) => {
    try {
        // If the item does not have an ID, generate a new one.
        // The max ID is generated by getting the maximum ID from the database and adding 1.
        // This is used as the ID for the new item.
        // If the item does have an ID, use that one instead.
        if (item.id === null) {
            item.id = await generateMaxId(db);
        }

        // Insert a new todo into the database.
        // The datetime('now') function is used to set the current date and time in the when_created column.
        await db?.runAsync('INSERT INTO todo (id, title, due, note, priority, notification, done, order_index, when_created) VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime(\'now\'));',
            [item.id, item.title ?? '', item.due ?? '', item.note ?? '', item.priority ?? '', item.notification ?? '', item.done ?? 0, item.order_index ?? 0]);
    } catch (error) {
        console.error("Error adding todo:", error);
    }
};

export const deleteTodo = async (db: SQLite.SQLiteDatabase | null, id: string) => {
    try {
        // Delete a todo from the database.
        // Identified by ID
        await db?.runAsync('DELETE FROM todo WHERE id = ?;', [id]);
    } catch (error) {
        console.error("Error deleting todo:", error);
    }
};

export const updateTodo = async (db: SQLite.SQLiteDatabase | null, item: ItemProps) => {
    try {
        // Get the current todo with the given ID
        const current = await getTodoById(db, item.id);
        if (!current) {
            throw new Error(`Todo with id ${item.id} does not exist`);
        }

        // Create a list of set values (key = ?, value = ?)
        // From the item object, filter out any values that are null
        // Map over the values and create a string of the format key = ?
        // Join the strings together with a comma
        const setValues = Object.entries(item).filter(([_, value]) => value !== null).map(([key, value]) => `${key} = ?`).join(', ');
        
        // Create an array of values to be used in the UPDATE query
        // Filter out any values that are null
        const values = Object.values(item).filter(value => value !== null);
        
        // If there are any set values, run the UPDATE query
        if (setValues) {
            await db?.runAsync(`UPDATE todo SET ${setValues} WHERE id = ?;`, [...values, item.id]);
        }
    } catch (error) {
        console.error("Error updating todo:", error);
    }
};

export const updateOrderIndexById = async (db: SQLite.SQLiteDatabase | null, id: number, order_index: number) => {
    try {
        // Update the order_index of the todo with the given id
        await db?.runAsync('UPDATE todo SET order_index = ? WHERE id = ?;', [order_index, id]);
    } catch (error) {
        console.error("Error updating order_index:", error);
    }
};


export const getAllTodos = async (db: SQLite.SQLiteDatabase | null) => {
    try {
        // Get all todos from the database.
        const result = await db?.getAllAsync<ItemProps>("SELECT * FROM todo");
        return result;
    } catch (error) {
        console.error("Error getting all todos:", error);
    }
};

export const getTodoById = async (db: SQLite.SQLiteDatabase | null, id: number) => {
    try {
        // Get a todo by ID from the database.
        const result = await db?.getFirstAsync<ItemProps>("SELECT * FROM todo WHERE id = ?", [id]);
        return result;
    } catch (error) {
        console.error("Error getting todo by ID:", error);
    }
};

export const deleteAll = async (db: SQLite.SQLiteDatabase | null) => {
    try {
        // Delete all todos from the database
        await db?.runAsync('DELETE FROM todo;', []);
    } catch (error) {
        console.error("Error deleting all todos:", error);
    }
};

export const countAll = async (db: SQLite.SQLiteDatabase | null): Promise<number> => {
    try {
        // Count all todos in the database
        const result = await db?.getFirstAsync<{ total: number }>(
            'SELECT COUNT(*) as total FROM todo;'
          );
        const count = result?.total ?? 0;
        return count;
    } catch (error) {
        console.error("Error counting all todos:", error);
        return 0;
    }
};

export const close = (db: SQLite.SQLiteDatabase | null) => {
    // Close the database.
    db?.closeSync();
};
